generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("PRISMA_DATABASE_URL")
  directUrl = env("POSTGRES_URL")
}

// ==================== AUTH MODELS ====================

model User {
  id                    String                @id @default(cuid())
  name                  String?
  pseudo                String                @default("Anonyme")
  email                 String                @unique
  emailVerified         DateTime?
  image                 String?
  role                  Role                  @default(READER)
  accounts              Account[]
  sessions              Session[]
  recipes               Recipe[]              @relation("UserRecipes")
  favorites             Recipe[]              @relation("UserFavorites")
  comments              Comment[]
  collections           Collection[]
  recipeNotes           UserRecipeNote[]
  personalNotes         UserNote[]            @relation("UserPersonalNotes")
  mealPlans             WeeklyMealPlan[]      @relation("UserMealPlans")
  mealPlanContributions MealPlanContributor[] @relation("MealPlanContributions")
  checkedIngredients    ShoppingListItem[]    @relation("CheckedIngredients")
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  deletedAt             DateTime? // Soft delete - RGPD compliant

  @@index([deletedAt])
  @@index([email, deletedAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum Role {
  OWNER // Super admin: ngmich95@gmail.com only, cannot be modified
  ADMIN // Full access: CRUD all recipes, manage users
  CONTRIBUTOR // Can add/edit own recipes
  READER // Can only view recipes and add favorites
}

// ==================== RECIPE MODELS ====================

model Recipe {
  id                 Int               @id @default(autoincrement())
  slug               String            @unique // URL-friendly identifier for SEO (e.g., "pho-bo-traditionnel")
  name               String
  description        String?
  category           String
  author             String            @default("Anonyme")
  imageUrl           String?
  videoUrl           String?
  preparationTime    Int               @default(0)
  cookingTime        Int               @default(0)
  rating             Float             @default(0) // Average rating from comments (0-10 with decimals)
  ratingCount        Int               @default(0) // Number of ratings
  ratingSum          Float             @default(0) // Sum of all ratings (for fast average calculation)
  servings           Int               @default(1)
  difficulty         String            @default("MEDIUM") // EASY, MEDIUM, HARD
  costEstimate       String? // CHEAP, MEDIUM, EXPENSIVE
  caloriesPerServing Int? // Calories per serving (optional)
  viewsCount         Int               @default(0) // Analytics: view count with throttling
  tags               String[]          @default([]) // Keywords: asiatique, riz, vietnamien, etc.
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  deletedAt          DateTime? // Soft delete - null = active, date = deleted
  ingredients        Ingredient[]
  ingredientGroups   IngredientGroup[]
  steps              Step[]
  comments           Comment[]

  // Auth relations
  userId       String?
  user         User?            @relation("UserRecipes", fields: [userId], references: [id], onDelete: SetNull)
  favoritedBy  User[]           @relation("UserFavorites")
  collections  Collection[]     @relation("CollectionRecipes")
  userNotes    UserRecipeNote[]
  plannedMeals PlannedMeal[]    @relation("PlannedMealRecipe")

  @@index([slug])
  @@index([category])
  @@index([userId])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([category, deletedAt])
  @@index([userId, deletedAt])
  @@index([deletedAt, createdAt])
  @@index([viewsCount])
}

model Comment {
  id        Int       @id @default(autoincrement())
  text      String
  rating    Float? // Optional rating 0-10 with decimals
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete - null = active, date = deleted

  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipeId Int
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@index([recipeId])
  @@index([userId])
  @@index([deletedAt])
  @@index([recipeId, deletedAt])
}

model Ingredient {
  id       Int     @id @default(autoincrement())
  name     String
  quantity Float?
  unit     String?
  order    Int     @default(0) // Pour l'ordre d'affichage dans le groupe
  recipeId Int
  recipe   Recipe  @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  // Groupe d'ingrédients (optionnel)
  groupId Int?
  group   IngredientGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)
}

model IngredientGroup {
  id          Int          @id @default(autoincrement())
  name        String // Ex: "Pour le riz", "Pour la viande", "Sauce"
  order       Int          @default(0) // Pour l'ordre d'affichage des groupes
  recipeId    Int
  recipe      Recipe       @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredients Ingredient[]
}

model Step {
  id       Int    @id @default(autoincrement())
  order    Int
  text     String
  recipeId Int
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
}

// ==================== COLLECTION & NOTES MODELS ====================

model Collection {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  color       String   @default("#f59e0b")
  icon        String   @default("folder")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipes     Recipe[] @relation("CollectionRecipes")

  @@unique([userId, name])
}

model UserRecipeNote {
  id        Int      @id @default(autoincrement())
  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipeId  Int
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@unique([userId, recipeId])
}

// Notes personnelles de l'utilisateur (idées de recettes, etc.)
model UserNote {
  id        Int      @id @default(autoincrement())
  title     String // Nom de l'idée de recette
  content   String? // Contenu optionnel (description, ingrédients, etc.)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation("UserPersonalNotes", fields: [userId], references: [id], onDelete: Cascade)
}

// ==================== MEAL PLANNER MODELS ====================

// ==================== SHOPPING LIST REALTIME ====================

model ShoppingListItem {
  id             Int       @id @default(autoincrement())
  ingredientName String // Nom de l'ingrédient (ex: "Tomates - 500g")
  category       String // Catégorie (ex: "Légumes")
  isChecked      Boolean   @default(false)
  checkedAt      DateTime? // Quand l'ingrédient a été coché

  // Qui a coché l'ingrédient
  checkedByUserId String?
  checkedByUser   User?   @relation("CheckedIngredients", fields: [checkedByUserId], references: [id], onDelete: SetNull)

  // Lien vers le plan de repas
  weeklyMealPlanId Int
  weeklyMealPlan   WeeklyMealPlan @relation("ShoppingListItems", fields: [weeklyMealPlanId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([weeklyMealPlanId, ingredientName, category])
  @@index([weeklyMealPlanId])
}

model WeeklyMealPlan {
  id        Int      @id @default(autoincrement())
  name      String // Ex: "Semaine du 14 décembre 2025"
  weekStart DateTime // Premier jour de la semaine (lundi)
  weekEnd   DateTime // Dernier jour de la semaine (dimanche)

  // Menu data
  numberOfPeople     Int
  budget             String
  cookingTime        String
  mealTypes          String[] // ["dejeuner", "diner"]
  cuisinePreferences String[] @default([])

  // Résumé nutritionnel
  avgCaloriesPerDay Int?
  proteinGrams      Int?
  carbsGrams        Int?
  fatGrams          Int?
  estimatedCost     String?

  // Liste de courses et conseils (JSON)
  shoppingList          Json? // {"Légumes": ["tomate x5"], "Viandes": [...]}
  optimizedShoppingList Json? // Liste optimisée par IA
  prepTips              String[] @default([])

  // Partage et visibilité
  isPublic Boolean @default(false) // Menu public ou privé

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete - null = active, date = deleted

  userId String
  user   User   @relation("UserMealPlans", fields: [userId], references: [id], onDelete: Cascade)

  meals             PlannedMeal[]
  contributors      MealPlanContributor[]
  shoppingListItems ShoppingListItem[]    @relation("ShoppingListItems")

  @@index([userId])
  @@index([deletedAt])
  @@index([userId, deletedAt])
  @@index([isPublic, deletedAt])
}

model MealPlanContributor {
  id      Int      @id @default(autoincrement())
  role    String // "CONTRIBUTOR" ou "VIEWER"
  addedAt DateTime @default(now())

  weeklyMealPlanId Int
  weeklyMealPlan   WeeklyMealPlan @relation(fields: [weeklyMealPlanId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("MealPlanContributions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([weeklyMealPlanId, userId])
  @@index([userId])
  @@index([weeklyMealPlanId])
}

model PlannedMeal {
  id           Int     @id @default(autoincrement())
  dayOfWeek    String // "Lundi", "Mardi", etc.
  mealType     String // "Petit-déjeuner", "Déjeuner", "Collation", "Dîner"
  timeSlot     String  @default("12:00") // "08:00", "12:00", "16:00", "19:00"
  name         String // Nom du plat
  prepTime     Int
  cookTime     Int
  servings     Int
  calories     Int?
  portionsUsed Int     @default(1) // Combien de portions utilisées (sur servings total)
  imageUrl     String? // URL de l'image de la recette (pour les recettes générées par IA)
  unsplashData String? // Métadonnées Unsplash (JSON) pour l'attribution du photographe

  // Données de la recette
  ingredients Json // ["ingrédient 1", "ingrédient 2"]
  steps       Json // ["étape 1", "étape 2"]

  // Lien vers une recette existante (optionnel)
  recipeId     Int?
  recipe       Recipe? @relation("PlannedMealRecipe", fields: [recipeId], references: [id], onDelete: SetNull)
  isUserRecipe Boolean @default(false)

  weeklyMealPlanId Int
  weeklyMealPlan   WeeklyMealPlan @relation(fields: [weeklyMealPlanId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
